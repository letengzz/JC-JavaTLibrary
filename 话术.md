# 自我介绍 

面试官 您好 我叫侯佳成 有过近四年的Java开发经验 先后就职于北京东方融创信息技术有限公司、上海多维度网络科技股份有限公司，在就职上海多维度网络科技股份有限公司 期间 ，参与爱抢购、好食期项目开发，其中爱抢购二期项目是从原本的项目基础上做了重构，提升访问速度和并发量。在就职东方融创期间 担任软件开发部 Java开发工程师 主要负责公司金融业务 的后端产品研发任务。我用过的技术栈有 Spring SpringBoot 、Mybatis、分布式框架 Spring Cloud及Spring Cloud的一些相关组件 如 redis、MySQL、MQ消息队列等技术。如果贵公司使用了相关技术，那么对于我来说还是比较容易上手能够很快的跟上项目的进度。感谢面试官，我的大体情况就是这样 

# 项目介绍

## 招联金融

说完自我介绍后，简单聊聊我最近参与的项目：招联金融。

招联金融是一款金融类应用，为用户提供全线上、免担保、低利率的普惠消费信贷服务。

该项目整体采用的架构是 SpringBoot 和 分布式微服务框架 SpringCloud 进行快速开发以及避免远程调用服务时出现访问超时宕机或者发生雪崩效应。

使用Nacos（那扣死 默认端口8848）服务注册与发现中心注册微服务，然后使用 openfeign 实现微服务的远程调用的功能，使用Sentinel进行服务降级，服务熔断，Gateway网关保护服务内部接口的安全，防止网络恶意访问以及进行限流操作。然后，我们项目组里边是6个后端开发，4个前端开发，我们后端开发是**根据功能开发模块**，主要划分为核心模块和非核心模块，将核心模块功能和非核心模块进行物理隔离。**登录、借款管理是核心功能，注册、用户信息是非核心功能**。登录功能⼀旦有问题，其他的业务系统，就不能登录了；而非核心功能即使有问题，暂时也不会⽴刻影响业务系统的使用。因此，优先保证核心功能正常，是我们首要的目标。 核心功能和非核心功能，可以有有不同的隔离、重试、降级策略。

## 项目整体架构

### 登录注册开发

关于注册登录服务的开发，注册具体交互流程是由前端请求统一账户服务获取短信验证码，前端校验手机号是否存在，校验验证码是否正确，如果不存在则说明未注册，前端发起注册请求，请求用户中心服务，用户中心服务请求统一账户服务保存注册信息，用户中心服务保存用户信息，注册成功。

如果使用快捷登录，比如微信登录的话，就是调用微信开放平台(申请账号、认证、开通微信登录)中的APPSecret(秘钥)，通过控制器来实现微信的快捷登录。用户在使用微信登录后，会获取一个openId,openId来源于微信第三方登录。

然后使用微信的接口去获取token

```java
String url = "https://api.weixin.qq.com/sns/oauth2/access_token";
Map<String, String> params = new HashMap<String, String>();
params.put("appid", appid);
params.put("secret", secret);
params.put("code", code);
params.put("grant_type", "authorization_code");
// System.out.println("=========url:"+url);
// System.out.println("=========params:"+params);
String result = HttpUtil.post(url, params, "utf-8");
//System.out.println("result"+result);
if (GeneralUtil.isNotNull(result)) {
JSONObject jsonObject = JSON.parseObject(result);
System.out.println("jsonObject"+jsonObject);
String openId = jsonObject.getString("openid");
String access_token = jsonObject.getString("access_token");
String unionid = jsonObject.getString("unionid");
```

### 信贷业务流程

组织架构、市场调研、产品设计、基础设施建设、营销获客、贷前审核、贷中管理、贷后管理



### 获取短信验证码

发送短信请求使用的是阿里的短信服务，流程大概是 

1. 先申请AccessKey(尔赛斯key)和AccessKey Secret(赛克瑞特) (登录阿里云官网的账号和密码并不能在代码中使用，在代码中想要登录阿里云就需要使用AccessKey和AccessKey Secret了，它和密码同等重要，所以不要告诉别人。AccessKey就相当于阿里云账号，AccessKey Secret就是密码，只不过这两个是在代码中的账号与密码，与我们网站登录的账号和密码没什么两样。

2. 申请成功后，需要再申请签名 (这种签名就相当于短信开头的LOGO 根据提示 填写签名审核通过即可) 申请完了每次发送短信的时候会自动加上的，不用我们手动去加添加签名

3. 接下来就是编写注册模板，也就是短信的内容 只不过在模板中可以指定一些变量(${}) 在使用的时候可以给这些变量赋值 用实际的值去替换这个变量 。编写完之后 等待审核就可以了

   ![image-20230516214322614](./assets/image-20230516214322614.png)

4. 编写注册模板之后 就可以在项目中使用短信服务了。阿里的短信服务在多种语言都配备了使用案例。

   在使用Java来编写代码时，首先导入 `aliyun-java-sdk-core`依赖。接下来就是将模板中的变量进行赋值  使用`putQueryParameter`这个api的最后一个参数就是进行参数的赋值，但是接收的是一个json格式的字符串，所以我们先将code作为键(键的名字要和模板中的变量名对应上)，变量值作为value放在map中，然后使用jackson将map转化为json字符串。有几个变量就可以将几个变量的名字作为key放在map中。

   **注意**：如果`putQueryParameter`最后一个参数只是放了普通字符串，那么返回结果中将提示JSON参数不合法

   在项目中需要修改accessKey和accessKey secret

   PhoneNumbers 就是手机号 SignName(塞音name)就是模板的名称。想用哪个模板就使用哪个编号 这个名称个人账户只允许申请一个

   ```java
public class SendSms {
       public static void main(String[] args) throws JsonProcessingException {
           DefaultProfile profile = DefaultProfile.getProfile("cn-hangzhou","accessKeyID", "accessKey Secret");
           IAcsClient client = new DefaultAcsClient(profile);
           CommonRequest request = new CommonRequest();
           request.setMethod(MethodType.POST);
           request.setDomain("dysmsapi.aliyuncs.com");
           request.setVersion("2017-05-25");
   		request.setAction("SendSms");
           request.putQueryParameter("RegionId", "cn-hangzhou");
           request.putQueryParameter("PhoneNumbers", "photo_number");
           request.putQueryParameter("SignName", "Repository");
           request.putQueryParameter("TemplateCode", "SMS_178766379");
           Map<String, String> map = new HashMap<String, String>(2);
           map.put("code", "123321");
           request.putQueryParameter("TemplateParam", new ObjectMapper().writeValueAsString(map));
           try {
               CommonResponse response = client.getCommonResponse(request);
               System.out.println(response.getData());
           } catch (ServerException e) {
               e.printStackTrace();
           } catch (ClientException e) {
               e.printStackTrace();
           }
       }
   }
   ```

5. 接下来就执行就可以收到短信了。

### 用户开户

关于用户开户服务的开发，开户是指借款用户和投资用户在注册后、交易前都需要在银行存管系统开通个人存管账户。以下是具体的业务流程是分成了三个阶段：

​    第一个阶段是**生成开户数据**，首先由用户发送开户的请求参数，用户中心会准备开户所需的基础数据（比如请求流水号，平台用户编号等，所需要的数据是要查看银行的存管系统API文档所需参数），并且会更新用户数据，保存银行卡信息后，用户中心会向存管代理服务通过远程调用发送开户请求数据，存管代理服务会保存交易记录，并且将同步状态设置为：未同步，之后再通过密钥去生成签名及数据。然后返回给用户中心签名及数据，用户中心会根据签名及数据，来返回开户的请求数据。

​    第二阶段是**请求开户**，就是返回的请求数据，跳转gateway网关开户接口，并且会给用户展示开户的界面，在用户填写并提交信息之后，存管系统就会去验证四要素，并且发给开卡银行，由开卡银行确认验证成功，则存管系统会对账户信息进行保存，并且保存其交易的记录，然后重定向到P2P平台，提示用户开户成功。

​    第三阶段就是**开户的结果通知**，在存管代理服务会回调存管系统信息，然后更新交易的记录，并且将交易状态由 未同步改为已同步，然后通过mq的异步通知，通知用户中心开户的结果是否成功，并且更新用户的信息。

### 登录授权模块

简单总结一下就是 使用 token和 jwt 实现无状态分布式身份验证

认证流程：客户端使用用户名跟密码请求登录，服务端收到登录请求，去验证用户名和密码，验证成功后，服务端会使用Oauth2密码模式去授权服务器去申请令牌，把这个令牌发送给客户端，存储到前端 sessionStorage，接下来客户端每次向服务端请求资源的时候需要带着服务端签发的令牌，客户端通过请求头携带令牌访问受限的资源服务器资源，如果验证成功,就向客户端返回请求的数据。资源服务器拿到令牌后通过RSA公钥验证令牌的合法性，同时使用spring security进行授权，控制不同的角色的令牌有不同的权限。

使用令牌认证，因为cookie-session 机制在分布式架构下的复杂性，故此项⽬中采取的是第⼆种方案：令牌认证。整合Spring Security Oauth2，Oauth2有四种模式，**授权码模式，密码模式，简化模式和客户端 模式**，这⾥使用Oauth2 密码模式颁发令牌 

为了提高令牌校验的效率，整合JWT，使用RSA 非对称加密算法，在授权服务器使用私钥颁发 JWT令牌，在资源服务器使用公钥校验令牌，有效提高令牌校验效率。

### 借款管理模块

作为一个金融借贷平台 借款管理模块是必不可少的模块，借款管理模块主要用于管理借款人的借款申请。包括借款的审核业务、贷款管理业务以及借款记录等。

#### 借款审核管理

我简单说一下借款审核业务是如何实现的。大致的流程就是 首先借款人在前台申请贷款后，提交借款申请，后台接收到请求后，使用 openfeign 远程调用管理员模块中身份为初审操作员进行初审。初审操作员初审后，由后端向前端返回审核结果码。前端通过审核结果码来判断初审是否通过。当初审不通过，借款人需要重新修改资料，重新提交申请，借款人也可以撤销借款申请。

当初审过后，借款人借款申请会调用到复审接口，就可以到复审列表查看复审记录，同样管理员模块中身份为复审操作员可以操作记录审核，当复审审核通过后，借款人的借款申请会生成一个标书，标书会展示到用户模块中身份为投资人的前台，然后投资人就可以看到标书信息，投资人可以进行投标，投资人投标后的钱只是冻结，并没真正的把你电子账户的钱划到借款人电子账户
当标书被投资人投资满以后，即标书进度为100%时候，可以在这里进行操作，满标放款，即把投资人电子账户的钱真正的划到借款人电子账户。

#### 额度管理

授信额度和贷款额度的主要区别是授信额度属于意向额度，而贷款额度是实际取现额度，授信额度会始终大于等于贷款额度。只有借款人的授信额度增加，他的贷款额度才可以增加，否则最大的贷款额度就是授信额度。

调用招商银行的积分信用接口(有一套金融信用资产评估) 对客户进行分析，基本信息 包括实名制认证手机号和用户的绑定、用户的信息、紧急联系人 、手持证件、学历信息接口认证、公司的基本信息、资产等 调用公共的接口。因为是一个招行的客户 需要在信用中心做一个资产的评估、做信用评级、调用银行其他规则的接口。



## 招联金融员工综合管理系统

### 搭建nacos集群



## 平顶山银行客户信息管理系统



## 好食期



## 爱抢购

该项目是上海多维度网络科技股份有限公司旗下的商品购物秒杀软件，主要为客户提供商品优惠 砍价等功能。

项目整体采用ssm框架 以及分布式微服框架springboot和springcloud。

网站一期需求：大约有20多个微服务，搭建了40个服务器。项目分为表现层模块、业务层服务、数据支撑系统。

表现层主要有后台管理系统、首页模块、搜索模块、商品分类模块、购物模块、单点登录模块、个人中心模块、评价模块。

业务层服务主要有管理服务、首页服务、搜索服务、商家服务、商品服务、订单服务、单点登录服务、redis服务、通知服务、消息服务、支付服务、用户服务、统计中心、用户服务、公告资讯服务、评价系统等。

数据支撑系统：redis集群、mysql集群。

项目使用nginx集群实现负载均衡，采用redis集群缓存降低对数据库的读写次数。

Spring Cloud 可以进行快速开发以及避免远程调用服务时出现访问超时宕机或者发生雪崩效应，使用hystrix(黑死追克斯)进行服务降级，服务熔断，采用nginx利用反向代理，eureka进行提供spring cloud服务的注册，feign组件实现服务远程调用，gateway集群充当网关保护服务内部接口的安全，防止网络恶意访问以及进行限流操作。

### 订单模块

简单聊一下我在一期项目负责的**订单模块**，在处理订单业务模块时，主要是使用redis缓存预订单，在缓存中减库存，只有在订单完成支付之后，发送到mq上，然后通过监听这个mq,来接受我们的订单对象，然后对我们的数据库进行写操作，包括数据库修改订单状态以及减库存，下单商品保存，以及收件人的添加，减少频繁访问数据库的压力。因为处理订单业务这一块比较复杂，涉及的点很多，大量用户的下单，产生的并发问题，还有网络的延迟或者是宕机，网络的恶意访问下单，订单入库超卖现象，需要考虑到这些问题，对于并发问题，我们用nginx实现负载均衡，将请求转发到gateway集群上，然后通过 LoadBalancer(楼的把兰斯) 负载均衡将请求转发到具体的服务上，并且统一管理配置对外暴露的服务接口，防止客户端非法请求内部服务接口。使用hystrix解决各服务之间的调用出现的问题，请求超时或者是导致服务宕机，通过配置进行服务降级和服务熔断，根据服务的性能去分配资源，避免单一服务不可用，导致影响其他服务。feign组件注册到eureka中，实现远程服务的调用。最后在支付完成之后，会在异步回调通知或者是查询订单接口中修改订单状态并且同时需要将redis中的缓存删除。

### 抢购模块

在二期的项目中，主要是添加了一个可插可拔的抢购模块，主要针对10W QPS的巨大流量峰值，根据LVS/Nginx/Tomcat/Spring Cloud Gateway/Redis/Mysql等业内参考吞吐量，进行系统各层中间件的逻辑架构分析和规划，在理论上确保流量峰值到达时，确保系统各层稳定性，不至于发生雪崩。 

**限流的架构与实现**：本地限流和分布式redis限流相结合的限流架构，通过Nginx的漏桶限流算法， 对于用户维度进行1r/m的限流策略。通过实现Redis+Lua分布式令牌桶限流组件，对于商品维度进行限流，对于每个sku进行限流10000r/s。 

**高并发读处理模型的设计和实现**：通过Lua+Nginx Cache + Redis的多级缓存模式。尽可能将秒杀 商品加载请求落地到Nginx Cache中，如果Nginx Cache缓存没有，在穿透到Redis缓存获取，在抢购暴露时，加载和更新Nginx Cache和Redis，保证数据⼀致性。 高并发写处理模型型效流量，也就是在Redis缓存中进⾏执⾏申请秒杀令牌（预备秒杀阶段），服务 层通过消息队列RocketMQ削峰，解决高并发写入⼯作（执⾏秒杀阶段） 

**接入层通过Nginx+Lua锁定有效流量的设计方案**：

预备秒杀阶段，通过Lua操作Redis，在接⼊层完 成秒杀令牌的发放，验证，通过Nginx+Lua这样的⾼性能组件，大大提升系统的吞吐量。识别了有 效请求后，有效请求在进⼊消息队列。 

服务层通过Redis实现的分段锁设计：由于加锁性能降低很多，借鉴ConcurrentHashMap思想，分段加锁，是串行写⼊，变为并发写⼊，大大提升性能。 通过RocketMQ的延迟队列解决，订单30分钟未⽀付，取消订单回滚库存的⼯作。 

**数据层的Mysql热点行更新性能的提升方案**：秒杀库存修改，是Mysql热点行数据更新，在高并发场景下更新会占用行锁，同⼀个sku的所有更新请求串行，性能不高，为了提高性能，讲⼀个sku库存 拆分成多行，可以大大提升性能。

10W QPS部署架构：接⼊层1个LVS+2个Nginx，承接10W QPS的巨⼤流量，通过Nginx限流和有效 流量识别之后，识别出有效的秒杀请求

### 支付模块

如果用户选择了支付宝支付，点击付款，请求进入后台之后，我们需要调用支付宝提供的接口。

支付宝支付：首先通过RSA2算法获取应用公钥和应用私钥，利用应用公钥在开发者中心配置生成支付宝公钥，密钥配置在交易数据时保证双方身份和数据的安全性，采用非对称验签算法，配置完成之后，需要支付宝提供的SDK（SDK封装了签名和验签过程)，AlipayClient 实例化对象，并且该实例是单例的，需要参数包括支付宝网关、appId、开发者应用私钥和应用公钥、支付宝公钥、字符编码格式以及签名类型（RSA2），实例化完成之后，调用alipay.trade.page.pay接口，创建AlipayTradePagePayRequest 对象，从redis中获取订单信息，然后转化为json字符串作为调用setBizContent()方法的参数，设置支付成功之后同步通知地址（returnUrl）和异步通知地址(notifyUrl)，注意异步通知这里需要通过验签，最后alipayClient调用接口pageExcute(reqest)，返回的是字符串（其实是一个表单，包括支付宝二维码以及一些订单的相关信息），第三方平台会渲染这个表单，返回到前端页面显示二维码以及订单相关信息。

支付成功之后，有可能因为网络问题，商户没有接收到支付宝发送的异步通知，需要商户主动去查询订单状态，自行调用alipay.trade.query接口，创建AlipayTradeQueryRequest对象，通过alipayClient对象调用excute(request)方法进行查询交易状态。

注意的点：支付宝支付有沙箱测试和正式环境，如果使用沙箱环境发布到外网上的话appid会显示无效。需要更改正式环境，包括appid和正式环境的网关。

还有支付宝多次回调的问题,在沙箱环境测试时,回调只会执行一次,但是发布到外网的时候会执行多次回调，这样会多次更新数据库操作，然后我在回调方法中将修改数据库的那段代码逻辑注释掉了，放在轮询访问用户支付状态的接口中,就不会重复多次调用了。这样会有一个问题，有可能到最后不会执行轮询访问用户支付状态的接口，那么就是用户实际下单了，订单状态还是未支付的状态。

**商户后台和微信支付系统后台的交互**：

首先想要实现微信扫码下单，商户后台必须要有订单编号，通过订单编号去请求微信支付系统调用统一下单API,生成预支付订单信息，然后商户接收，该信息中包含有code_url，返回给前端，利用QRious工具将code_url链接生成二维码图片显示在页面上。

阶段二：客户端和微信支付系统的交互

用户扫码提交支付信息，微信支付系统验证信息的有效性，用户授权，微信支付系统授权验证和支付完成之后，同步通知客户端交易成功信息。

**商户后台和微信支付系统的交互**：

支付完成之后，微信支付系统会异步通知商户后台支付结果，并返回微信支付后台的接收情况。

但是，还有可能网络问题导致商户后台没有及时收到支付结果，无法去修改订单状态以及redis中的数据，所以就需要在页面上写一个定时器setInterval(),当扫码完成之后，每隔一段时间去请求微信后台调用查询订单api（orderquery ）,返回给商户支付结果。

实现过程：

主要是根据文档中提供的url接口链接来创建HttpClient客户端对象,通过map集封装文档中提供的基本参数，参数可以配置在xml中，注解@Value获取，调用WXPayUtil中generateSingedXml()方法已经封装的参数和partnerKey商户秘钥参数生成带有签名的xml格式的参数，httpClient对象通过post去发送，通过httpclient客户端对象调用getContent()接受返回结果包括code_url、订单编号、金额这些信心,然后返回值结果再通过WXPayUtil.XmltoMap()方法转化为map集合，返回给客户端生成二维码。用户需要在指定时间内进行支付，如果超时，需要调用关闭订单接口，然后重新生成二维码。

支付成功之后，需要检测支付订单的状态，根据文档提供的url链接接口，调用订单查询api，返回结果中trade_state是success时订单支付成功，否则支付失败需要调用文档中提供的url链接进行关闭订单。

系统能够查询到支付记录，以及因为网络等问题导致的已支付订单的订单状态没有改变，后面就需要日志记录去解决这两个问题，需要在生成订单的时候，需要向日志记录表中添加订单记录，并且同时保存到redis中，后期可以再redis中获取订单信息封装参数生成二维码，支付成功之后，修改日志记录表中的支付状态，以及订单表中的支付状态,并且清除redis缓存中的日志记录。

需要注意的是，支付状态查询时返回结果是空的，那么要调用关单接口（closeorder）。

**接口调用过程**：

需要下载短信开发sdk和demo,把demo封装成我们自己的工具类来调用。封装的方法接收参数包括签名，模板号，手机号，参数（申请模板中的参数），创建sendsmsrequest对象，封装传递的参数，然后使用acsClient对象调用接getAcsResponse接口发送短信。返回值包括message短信内容和bizID用于查询短信信息。

接下来就是调用这个我们封装的这个工具类。创建一个方法生成随机的6位数，保存入redis中，同时发送到mq上，定义一个监听方法使用注解@jmsListener监听该队列，然后呢接受到消息时，调用我们前面封装的短信工具类然后返回短信验证码。然后发送到mq上，然后监听该队列的方法会接收到消息，开始调用短信工具类发送短信验证码。

用户注册时，需要将接收到的验证码和redis中保存的验证码相同是才能注册成功。

jmsTemplate.send(“目的队列”，new messageCreator(){

实现接口的createMessage(session)

 session创建mapMessage对象，

封装参数签名，申请模板id、手机号，以及随机字符串,就是模板参数，是json格式字符串。

然后返回mapMessage对象。})，



包括：金融信用平台 数字智能信用平台

这几年的技术栈为spring cloud 

接下来 介绍一下项目情况：

1. 项目的背景：甲方：上海邵野网络科技有限公司旗下的大河票务网，主要针对河南地区演艺订票平台的业务。

2. 业务背景：

   网站一期需求：大约有20多个微服务，搭建了40个服务器。项目分为表现层模块、业务层服务、数据支撑系统。

   表现层:后台管理系统、首页模块、搜索模块、演出票分类模块、购物车模块、订单模块、单点登录模块、个人中心模块、论坛模块、评价模块。

   业务层服务:管理服务、首页服务、搜索服务、商品服务、购物车服务、订单服务、单点登录服务、redis服务、通知服务、消息服务、支付服务、用户服务、统计中心、用户服务、公告资讯服务、论坛平台、评价系统等。

   数据支撑系统：redids集群、mysql集群、mycat中间件

   网站二期：对架构进行重构，采用cloudali 组件进行拆分 并吧秒杀业务单独拆分出一个微服务。

3. **技术背景**：架构罗列讲一下：

   开发工具/开发环境**：**

   框架及组件

   数据库

   中间件

   应用的插件

   前端

   测试工具 ：postman swagger

   部署平台：jekins docker K8S

4. 角色：主要负责什么 独立开发的子功能和功能模块 

5. **我负责用户模块开发：注册** **登录** **个人中心** **会员中心** **优惠券** **基础服务管理** **数据字典等功能**

   **功能数据库设计：用户信息表** **用户角色表** **用户权限菜单表** **会员信息表** **积分明细表** **优惠卷信息表** **积分规则表** **数据字典表等等**

   **权限管理：主要是三张主表** **用户信息表** **用户角色表** **用户权限菜单表，两张中间表 5张表关联，用JWT实现用户的鉴权和认证：**

收获：

我把这几年的学习情况介绍一下： 我毕业于 学院，在校期间成绩排名前列 期间获得过奖学金

我大概工作着3年多，代码量和跟的业务也还可以，如果咱们比较匹配，我觉得上手还是挺快的，如果咱们那边自己框架 我学习能力还可以，也比较喜欢新的技术，希望能有机会合作，谢谢

我今天求职的是Java 岗位 本身是软件工程 对口方向就是Java 自己本身也很感兴趣

# 面试相关问题

## 架构

## Spring Security

Spring Security是一个基于Spring框架的安全框架，提供了完整的安全解决方案，包括认证、授权、攻击防护等功能。

其核心功能包括：

- 认证：提供了多种认证方式，如表单认证、HTTP Basic认证、OAuth2认证等，可以与多种身份验证机制集成。


- 授权：提供了多种授权方式，如角色授权、基于表达式的授权等，可以对应用程序中的不同资源进行授权。


- 攻击防护：提供了多种防护机制，如跨站点请求伪造（CSRF）防护、注入攻击防护等。


- 会话管理：提供了会话管理机制，如令牌管理、并发控制等。


- 监视与管理：提供了监视与管理机制，如访问日志记录、审计等。


Spring Security通过配置安全规则和过滤器链来实现以上功能，可以轻松地为Spring应用程序提供安全性和保护机制。

### Spring Security的原理

Spring Security是一个基于Spring框架的安全性认证和授权框架，它提供了全面的安全性解决方案，可以保护Web应用程序中的所有关键部分。

Spring Security的核心原理是拦截器（Filter）。Spring Security会在Web应用程序的过滤器链中添加一组自定义的过滤器，这些过滤器可以实现身份验证和授权功能。当用户请求资源时，Spring Security会拦截请求，并使用配置的身份验证机制来验证用户身份。如果身份验证成功，Spring Security会授权用户访问所请求的资源。


Spring Security的具体工作原理如下：

1. 用户请求Web应用程序的受保护资源。

2. Spring Security拦截请求，并尝试获取用户的身份验证信息。

3. 如果用户没有经过身份验证，Spring Security将向用户显示一个登录页面，并要求用户提供有效的凭据（用户名和密码）。

4. 一旦用户提供了有效的凭据，Spring Security将验证这些凭据，并创建一个已认证的安全上下文（SecurityContext）对象。

5. 安全上下文对象包含已认证的用户信息，包括用户名、角色和授权信息。

6. 在接下来的请求中，Spring Security将使用已经认证的安全上下文对象来判断用户是否有权访问受保护的资源。

7. 如果用户有权访问资源，Spring Security将允许用户访问资源，否则将返回一个错误信息。

### 有哪些控制请求访问权限的方法

在Spring Security中，可以使用以下方法来控制请求访问权限：

- `permitAll()`：允许所有用户访问该请求，不需要进行任何身份验证。

- `denyAll()`：拒绝所有用户访问该请求。

- `anonymous()`：允许匿名用户访问该请求。

- `authenticated()`：要求用户进行身份验证，但是不要求用户具有任何特定的角色。

- `hasRole(String role)`：要求用户具有特定的角色才能访问该请求。

- `hasAnyRole(String... roles)`：要求用户具有多个角色中的至少一个角色才能访问该请求。

- `hasAuthority(String authority)`：要求用户具有特定的权限才能访问该请求。

- `hasAnyAuthority(String... authorities)`：要求用户具有多个权限中的至少一个权限才能访问该请求。

可以将这些方法应用于Spring Security的配置类或者在Spring Security注解中使用。

### hasRole 和 hasAuthority 有区别吗？

在Spring Security中，hasRole和hasAuthority都可以用来控制用户的访问权限，但它们有一些细微的差别。

hasRole方法是**基于角色进行访问控制的**。它检查用户是否有指定的角色，并且这些角色以"ROLE_"前缀作为前缀（例如"ROLE_ADMIN"）。

hasAuthority方法是**基于权限进行访问控制的**。它检查用户是否有指定的权限，并且这些权限没有前缀。

因此，使用hasRole方法需要在用户的角色名称前添加"ROLE_"前缀，而使用hasAuthority方法不需要这样做。

例如，假设用户有一个角色为"ADMIN"和一个权限为"VIEW_REPORTS"，可以使用以下方式控制用户对页面的访问权限：

```java
.antMatchers("/admin/**").hasRole("ADMIN")
.antMatchers("/reports/**").hasAuthority("VIEW_REPORTS")
```

在这个例子中，只有具有"ROLE_ADMIN"角色的用户才能访问/admin/路径下的页面，而具有"VIEW_REPORTS"权限的用户才能访问/reports/路径下的页面。

### 如何对密码进行加密

在 Spring Security 中对密码进行加密通常使用的是密码编码器（PasswordEncoder）。PasswordEncoder 的作用是将明文密码加密成密文密码，以便于存储和校验。Spring Security 提供了多种常见的密码编码器，例如 BCryptPasswordEncoder、SCryptPasswordEncoder、StandardPasswordEncoder 等。

以 BCryptPasswordEncoder 为例，使用步骤如下：

1. 在 pom.xml 文件中添加 BCryptPasswordEncoder 的依赖：

   ```xml
   <dependency>
       <groupId>org.springframework.security</groupId>
       <artifactId>spring-security-crypto</artifactId>
       <version>5.6.1</version>
   </dependency>
   ```

2. 在 Spring 配置文件中注入 BCryptPasswordEncoder：

   ```java
   @Configuration
   public class SecurityConfig extends WebSecurityConfigurerAdapter {
       
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
       
       // ...
   }
   ```

3. 在使用密码的地方调用 passwordEncoder.encode() 方法对密码进行加密，例如注册时对密码进行加密：

   ```java
   @Service
   public class UserServiceImpl implements UserService {
    
       @Autowired
       private PasswordEncoder passwordEncoder;
    
       @Override
       public User register(User user) {
           String encodedPassword = passwordEncoder.encode(user.getPassword());
           user.setPassword(encodedPassword);
           // ...
           return user;
       }
    
       // ...
   }
   ```

以上就是使用 BCryptPasswordEncoder 对密码进行加密的步骤。使用其他密码编码器的步骤类似，只需将 BCryptPasswordEncoder 替换为相应的密码编码器即可。

### Spring Security基于用户名和密码的认证模式流程

请求的用户名密码可以通过表单登录，基础认证，数字认证三种方式从HttpServletRequest中获得，用于认证的数据源策略有内存，数据库，ldap,自定义等。

拦截未授权的请求，重定向到登录页面的过程：

- 当用户访问需要授权的资源时，Spring Security会检查用户是否已经认证（即是否已登录），如果没有登录则会重定向到登录页面。


- 重定向到登录页面时，用户需要输入用户名和密码进行认证。


表单登录的过程：

- 用户在登录页面输入用户名和密码，提交表单。


- Spring Security的UsernamePasswordAuthenticationFilter拦截表单提交的请求，并将用户名和密码封装成一个Authentication对象。


- AuthenticationManager接收到Authentication对象后，会根据用户名和密码查询用户信息，并将用户信息封装成一个UserDetails对象。


- 如果查询到用户信息，则将UserDetails对象封装成一个已认证的Authentication对象并返回，如果查询不到用户信息，则抛出相应的异常。


- 认证成功后，用户会被重定向到之前访问的资源。如果之前访问的资源需要特定的角色或权限才能访问，则还需要进行授权的过程。


Spring Security的认证流程大致可以分为两个过程，首先是用户登录认证的过程，然后是用户访问受保护资源时的授权过程。在认证过程中，用户需要提供用户名和密码，Spring Security通过UsernamePasswordAuthenticationFilter将用户名和密码封装成Authentication对象，并交由AuthenticationManager进行认证。如果认证成功，则认证结果会存储在SecurityContextHolder中。在授权过程中，Spring Security会检查用户是否有访问受保护资源的权限，如果没有则会重定向到登录页面进行认证。

拦截未授权的请求，重定向到登录页面

![img](https://img-blog.csdnimg.cn/img_convert/06665f27cc014883992092362c628f80.png)

表单登录的过程，进行账号密码认证

![img](https://img-blog.csdnimg.cn/img_convert/799b870a8a214625b2029cce40ae2b0c.png)

## Oauth

OAuth 是一个行业的标准授权协议，主要用来授权第三方应用获取有限的权限。而 OAuth 2.0是对 OAuth 1.0 的完全重新设计，OAuth 2.0更快，更容易实现，OAuth 1.0 已经被废弃。详情请见：rfc6749。

实际上它就是一种授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 token，使得第三方应用能够通过该令牌获取相关的资源。

OAuth 2.0 比较常用的场景就是第三方登录，当你的网站接入了第三方登录的时候一般就是使用的 OAuth 2.0 协议。

另外，现在OAuth 2.0也常见于支付场景（微信支付、支付宝支付）和开发平台（微信开放平台、阿里开放平台等等）。

### OAuth的工作原理

1、资源所有者（Resource Owner）：一般是指咱们自己

2、客户端（Client）：一般是指需要授权的应用，比如京东APP

3、资源服务器（Resource Server）：一般是指保存信息的服务器，比如QQ密码和微信密码的服务器。

4、授权服务器（Authorization Server）：一般是指提API的服务器，比如QQ的Open API服务，微信的Open API服务。

一般情况下，资源服务器和认证服务器是同一个服务，这样更方便调用。OAuth的工作原理如图所示：
![img](https://img-blog.csdnimg.cn/img_convert/a4c63fe9a610c5cc5a625980a0dc8fc9.jpeg)

第1步，客户端向资源拥有者发送授权请求，一般资源拥有者的资源会存放在资源服务器。

第2步，客户端会收到资源服务器的授权许可，

第3步：客户端拿到许可之后，再向授权服务器发送一次验证，给客户端颁发一个Access Token访问令牌。

第4步：客户端拿到令牌之后，交给资源服务器。

第5步：资源服务器会将获取到的令牌传给认证服务器验证令牌的有效性。

第6步：资源服务器验证令牌通过之后，就会返回一个受保护的资源。

在我们看到的这个流程中，最重要的是第2步，也就是在第3步获取授权之前，客户端要先申请许可资源的内容，比如用户头像，用户昵称等等。也就是客户端向资源服务器申请授权的时候，需要填写以下授权所需的信息，分别是：应用名称、应用网站、重定向URI或者回调的URL（redirect_uri）、客户端标识client_id和客户端密钥client_secret。这些信息需要我们在 。

### Token Auth的优势

1.支持跨域访问: Cookie是不允许垮域访问的,这一点对 Token机制是不存在的,前提是传输的用户认证信息通过HTTP头传输.
2.无状态(也称:服务端可扩展行) :Token机制在服务端不需要存储 session信息,因为Token自身包含了所有登录用户的信息,只需要在客户端的 Cookie或本地介质存储状态信息
3.更适用CDN:可以通过内容分发网络请求你服务端的所有资料(如: Javascript,HTML,图片等),而你的服务端只要提供API即可
4.去耦:不需要绑定到一个特定的身份验证方案。 Token可以在任何地方生成,只要在你的API被调用的时候,你可以进行 Token生成调用即可
5.更适用于移动应用:当你的客户端是一个原生平台(iOS, Android, Windows8等)时, Cookie是不被支持的(你需要通过 Cookie容器进行处理),这时采用 Token认证机制就会简单得多。
6.CSRF:因为不再依赖于 Cookie,所以你就不需要考虑对CSRF(跨站请求伪造)的防范。
7.性能:一次网络往返时间(通过数据库查询 session信息.)总比做一次 HMACSHA256计算的 Token验证和解析要费时得多。
8.不需要为登录页面做特殊处理:如果你使用 Protractor做功能测试的时候,不再需要为登录页面做特殊处理
9.基于标准化:你的API可以采用标海化的 JSON Web Token(WT.这个标准已经存在多个后端库(NET, Ruby, Java. Python,PHP)和多家公司的支持(如Firebase. Google, Microsoft)

## JWT

`JWT`是`token`的一种具体实现方式，其全称是`JSON Web Token`，官网地址：https://jwt.io/

通俗地说，**JWT的本质就是一个字符串**，它是将用户信息保存到一个Json字符串中，然后进行编码后得到一个`JWT token`，**并且这个`JWT token`带有签名信息，接收后可以校验是否被篡改**，所以可以用于在各方之间安全地将信息作为Json对象传输。JWT的认证流程如下：

1. 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口，这个过程一般是一个`POST`请求。建议的方式是通过SSL加密的传输(HTTPS)，从而避免敏感信息被嗅探
2. 后端核对用户名和密码成功后，**将包含用户信息的数据作为JWT的Payload，将其与JWT Header分别进行Base64编码拼接后签名**，形成一个`JWT Token`，形成的`JWT Token`就是一个如同`lll.zzz.xxx`的字符串
3. 后端将`JWT Token`字符串作为登录成功的结果返回给前端。前端可以将返回的结果保存在浏览器中，退出登录时删除保存的`JWT Token`即可
4. **前端在每次请求时将`JWT Token`放入HTTP请求头中的`Authorization`属性中**(解决XSS和XSRF问题)
5. 后端检查前端传过来的`JWT Token`，验证其有效性，比如检查签名是否正确、是否过期、token的接收方是否是自己等等
6. 验证通过后，后端解析出`JWT Token`中包含的用户信息，进行其他逻辑操作(一般是根据用户信息得到权限等)，返回结果

![img](https://img-blog.csdnimg.cn/img_convert/900b3e81f832b2f08c2e8aabb540536a.png)

### 为什么要用JWT

#### 传统Session认证的弊端

我们知道**HTTP本身是一种无状态的协议**，这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，认证通过后HTTP协议不会记录下认证后的状态，那么下一次请求时，用户还要再一次进行认证，因为根据HTTP协议，我们并不知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在用户首次登录成功后，在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为`cookie`，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这是传统的基于`session`认证的过程

![img](https://img-blog.csdnimg.cn/img_convert/29cfe2cc7bd13bc659227e62c3e89063.png)

然而，传统的`session`认证有如下的问题：

- 每个用户的登录信息都会保存到服务器的`session`中，**随着用户的增多，服务器开销会明显增大**
- 由于`session`是存在与服务器的物理内存中，所以**在分布式系统中，这种方式将会失效**。虽然可以将`session`统一保存到Redis中，但是这样做无疑增加了系统的复杂性，对于不需要redis的应用也会白白多引入一个缓存中间件
- **对于非浏览器的客户端、手机移动端等不适用**，因为`session`依赖于`cookie`，而移动端经常没有`cookie`
- 因为`session`认证本质基于`cookie`，所以如果`cookie`被截获，用户很容易收到跨站请求伪造攻击。并且如果浏览器禁用了`cookie`，这种方式也会失效
- 前后端分离系统中更加不适用，后端部署复杂，前端发送的请求往往经过多个中间件到达后端，`cookie`中关于`session`的信息会转发多次
- 由于基于Cookie，而**cookie无法跨域，所以session的认证也无法跨域，对单点登录不适用**

#### JWT认证的优势

对比传统的`session`认证方式，JWT的优势是：

- 简洁：`JWT Token`数据量小，传输速度也很快
- 因为JWT Token是以JSON加密形式保存在客户端的，所以JWT是**跨语言**的，原则上任何web形式都支持
- 不需要在服务端保存会话信息，也就是说**不依赖于cookie和session，所以没有了传统session认证的弊端，特别适用于分布式微服务**
- **单点登录友好**：使用Session进行身份认证的话，由于cookie无法跨域，难以实现单点登录。但是，使用token进行认证的话， **token可以被保存在客户端的任意位置的内存中，不一定是cookie，所以不依赖cookie**，不会存在这些问题
- **适合移动端应用**：使用Session进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到Cookie（需要 Cookie 保存 SessionId），所以不适合移动端

> 因为这些优势，目前无论单体应用还是分布式应用，都更加**推荐用JWT token的方式进行用户认证**

# JWT结构

JWT由3部分组成：标头([Header](https://so.csdn.net/so/search?q=Header&spm=1001.2101.3001.7020))、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用`.`进行连接形成最终传输的字符串

## Redis

我们项目主要使用Redis 来用作缓存层 主要是考虑节省数据处理流程和服务器的资源消耗，减少服务器和db压力。因为数据库的查询比较耗时，使用缓存能大大节省数据访问的时间。同时，数据库的承载能力并不能应对高并发问题，而Redis能承载超过10w qps 承载能力大大高于数据库的承载能力。

我们主要使用的是Redis 的 CLUSTER模式来做集群，主要做了六主六从，实现对Redis 的高可用。

**主要使用在金融行业的哪些业务场景？** 业务系统的session数据缓存，尤其是手机APP的后端缓存服务。

我们的做法就是 把数据加入缓存，每次加载数据之前，先去缓存中加载，如果为空，再去查询数据库并将数据加入 缓存，这样可以大大提高数据访问的效率。

针对10W QPS的巨⼤流量峰值，根据LVS/Nginx/Tomcat/Spring Cloud Gateway/Redis/Mysql等业内参考吞吐量，进⾏系统各层中间件的逻辑架构分析和规划，在 理论上确保流量峰值到达时，确保系统各层稳定性，不⾄于发⽣雪崩。

### Cluster 集群

Redis Cluster 将所有数据划分为 16384 的 slots，它比 Codis 的 1024 个槽划分得更为精细，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中，它不像 Codis，它不需要另外的分布式存储来存储节点槽位信息。
Redis Cluster是一种服务器Sharding技术(分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。Redis Cluster集群采用了P2P的模式，完全去中心化。

Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽。
为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有1-n个从节点。
例如master-A节点不可用了，集群便会选举slave-A节点作为新的主节点继续服务。

CLUSTER集群是基于Redis的一个分布式实现。它引入了**哈希槽**的概念，支持动态添加或删除节点，可线性扩展至1000个节点，多个Redis节点之间数据共享，部分节点不可达时集群仍可用，数据通过异步复制，不保证数据的强一致性，具备自动FAILOVER的能力，客户端直接连接Redis SERVER，免去PROXY性能的消耗。

Redis CLUSTER是一种去中心化的结构。所有节点之间互相连接，通过GOSSIP协议来**发布广播消息**，每间隔时间内互相发送PING/PONG心跳包来检测其他节点状态，来保持信息同步，客户端直接连接任意Redis SERVER，并由Redis CLUSTER路由转发客户端请求到真正请求数据的节点。

![Redis 在互联网金融账务核心系统中的应用_java_03](https://s2.51cto.com/images/blog/202105/07/7e008929f41674a9a4fcdfcc08b5a3e5.jpeg?x-oss-process=image/format,webp/resize,m_fixed,w_1184)

CLUSTER集群数据同步原理还是延续主从模式，在此就不再重复的描述，在此着重说明一下CLUSTER集群的路由原理。**当操作某个KEY时，Redis CLUSTER节点并不是采取代理的模式直接寻找到这个KEY所在的节点并执行命令，而是将客户端重定向到存储这个KEY的节点，通过对KEY的操作，客户端会记录路由地址，最终客户端获得每个节点负责的KEY最新信息。**

![Redis 在互联网金融账务核心系统中的应用_java_04](https://s2.51cto.com/images/blog/202105/07/f6f3599289842815bf907449fc52a62a.jpeg?x-oss-process=image/format,webp/resize,m_fixed,w_1184)

在一般情况下，对于给定的操作，客户端会直接连接正确的节点并执行命令。与单点Redis不一样的是，CLUSTER集群引入了哈希槽概念，而且不是一致性哈希来实现，共有16384个哈希槽。每个MASTER节点只负责一部分哈希槽，每个KEY通过HASH_SOLT=CRC16(KEY)%16384来计算属于哪一个节点。

CLUSTER模式用户高可用的需求场景，更偏向于数据量较高的高可用CACHE、存储场景。因此，在互联网金融账务核心系统中，更偏向于选择REDIS CLUSTER。

### 测试Redis

我们主要使用的是 benchmark 测试工具，benchmark是一个压力测试工具，用于测试 Redis 的性能。

## MQ

## MySQL



## LVS

## NGINX

因为Nginx 占有内存少，并发处理能力强(能处理2-3万并发连接数)，高性能 处理响应快、低系统资源消耗。所以我们在Redis缓存层前加入了Nginx 来做 **静态网站的部署、负载均衡以及静态代理**。

- 占内存小，可实现高并发连接，
- 可实现http服务器、虚拟主机、方向代理、负载均衡
- Nginx配置简单
- 可以不暴露正式的服务器IP地址

### 正向代理和反向代理

#### 正向代理

正向代理是一个位于客户端和目标服务器之间的代理服务器（中间服务器）。为了从目标服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转发请求，将获得的内容返回给客户端。正向代理的情况下，客户端必须要进行一些特殊的设置才能使用。 

![image-20230521140714033](./assets/image-20230521140714033.png)

**主要用处**：

- **突破访问显示**：通过代理服务器，可以突破自身ip访问限制，访问国外网站等
- **提高访问速度**：通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度
- **隐藏客户端真实ip**：上网者可以通过正向代理的方法隐藏自己的ip，免受攻击

#### 反向代理

反向代理是指以代理服务器来接收客户端的请求，然后将请求转发给内部网络上的服务器，将从服务器上得到的结果返回给客户端，此时代理服务器对外表现为一个反向代理服务器。

![image-20230521140955020](./assets/image-20230521140955020.png)

**主要用处**：

- **隐藏服务器真实ip**：使用反向代理，可以对客户端隐藏服务器的ip地址
- **负载均衡**：反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上
- **提高访问速度**：反向代理服务器可以对静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度
- **提供安全保障**：反向代理服务器可以作为应用层防火墙，为网站提供对基于web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。

#### 正向代理和反向代理的异同 

- 相同点：
  - 正向代理和反向代理所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端。
- 不同点：
  - 正向代理是客户端的代理，服务器不知道真正的客户端是谁；反向代理是服务器的代理，客户端不知道真正的服务器是谁
  - 正向代理一般是客户端架设的；反向代理一般是服务器架设的
  - 正向代理主要是用来解决访问限制问题；反向代理则是提供负载均衡、安全防护等作用。二者都能提高访问速度

### Nginx基本运行原理

![image-20230521141759783](./assets/image-20230521141759783.png)

Nginx 大概的运行原理是 在这个nginx 的主目录下有一个/sbin/nginx的可执行文件 ，运行nginx 的时候把这个可执行文件执行起来，这个可执行文件执行起来之后，首先会开启一个master的主进程，主进程会把配置文件读取出来，再把配置文件在进行校验，看看配置文件有没有错误，如果没有错误会开启多个子进程worker来接收响应请求。master主进程不处理业务，而是去协调多个worker子进程，所以进程、子进程都启动之后，就会等待用户的请求接入进来，接入之后由一个worker进程来响应并解析请求，读取conf中的nginx配置文件 找到这个目录位置 然后找到文件 读取文件 来响应给用户

是一个多进程的，由多个进程来完成用户的请求，master主进程去协调多个worker子进程当nginx配置文件更改了，reload一下，master进程会把worker进程来杀掉，在杀掉进程之前 会让这个worker留有一段时间去完成之前用户的请求 ，并不允许他再接续新的请求，所有任务完成之后，这个worker被杀掉了 。新的worker进程就会读取新的配置文件。

### 零拷贝 

简单来说就是不需要复制和拷贝了 免除了中间的一次拷贝环节，既减少中间的调度的过程，又减少了复制的过程

当不开启零拷贝的时候，就是请求打入到Nginx中，请求由这个网络接口来转发到Nginx中

要到磁盘来找文件。没开启就先读出来这个文件 完整的加载出来，加载在应用程序的内存中。通过应用程序的内存来发送到网络接口缓存等层层缓存后 ，网络接口将这个数据推送到用户

![image-20230521152709226](./assets/image-20230521152709226.png)

有sendfile 之后 通过nginx应用内存不需要读取文件，而是发送一个sendfile的信号

sendfile 会传递socket等信息 发送到网络接口缓存来读取文件，直接通过网络发送给用户

少了一个拷贝环节。

![image-20230521152714662](./assets/image-20230521152714662.png)

### Nginx 负载均衡

主要通过conf核心配置文件中的http配置来实现负载均衡。

使用upstream 上游服务器组配置。通过轮询、权重、ip_hash、hash、最少连接来进行负载均衡

### location匹配顺序

location匹配顺序
   	1. nginx服务器首先在server块的多个location块中搜索是否有标准的uri和请求字符串匹配。如果有多个标准uri可以匹配，就匹配其中匹配度最高的一个location。
   	2. nginx在使用location块中，正则uri和请求字符串，进行匹配。如果正则匹配成功，则结束匹配，并使用这个location处理请求；如果正则匹配失败，则使用标准uri中，匹配度最高的location。
   	3. 类型之间的优先级： **精准匹配>普通匹配>正则匹配>“/” 默认根路径匹配**。
   	4. 普通匹配同类型location之间的优先级：最长前缀优先。普通匹配的优先级，与location在配置文件中所处的先后顺序无关，而与匹配到的前缀长度有关
   	5. 正则匹配同类型location之间的优先级为顺序优先。 只要匹配到第⼀个正则规则的location，就停止后面的正则规则的测试。 正则匹配与location规则定义在配置⽂件中的先后顺序强相关。

### Nginx 调优

可以从多个方面来进行调优，就比如说：

1. 针对 worker_processes 的进程数，数量要与CPU数量一致，通过`lscpu`查看：

   ```nginx
   worker_processes 1; 
   ```

2. 优化nginx的worker进程最多打开数量的参数：

   

## 缓存问题

### 不用使用缓存的场景

服务器、db压力不大的不需要使用缓存。

在数据被更新之后需要立即看到更新后的数据，不适合使用缓存，所以不建议使用缓存。

****

同样的电商管理后台，这次是一个统计页面，统计昨天/今天/近一周的商品销售情况。

这个场景可以分情况来看，有多种不同的解决方案。

a. 不需要实时统计，只需要定时统计一次即可，比如只看昨天一天统计数据：可以由定时脚本统计之后直接存储在db，需要查看统计数据时直接查询db即可

b. 需要查询实时统计数据，但需要查询的各个统计sql执行效率满足预期：每次查看数据直接查询db即可，此时db压力不大

### 缓存的设计

我们项目对于缓存时间进行了设计：

- 针对请求参数多变，返回的数据如果跟请求参数强相关，适合在 请求参数过滤 之后，缓存查询到的数据。


这类数据一般缓存时间短，比如缓存5分钟。主要应对相同请求参数在短时间内的重复请求。

如果遇到请求攻击，即使这个缓存有效期只有1秒，也是很有效的，能挡住大量的请求。

- 针对请求参数变化不大, 返回的数据跟db中存储的数据很接近的情况, 适合在“里面”缓存数据, 也就是在更新db的同时更新缓存, 这种情况最优的状态下, 只需要读缓存就够了, 不需要跟db直接交互, 能大大缓解db压力。

获取和过滤请求参数这边异步代码处理多用户处理需要加互斥锁 否则会出现数据覆盖

### 三级缓存

⾸先查询nginx缓存，没有去redis缓存中查询，如果redis 中没有在⾛java服务，从java缓存，比如guava中获取数据，如果都没有，在最终从mysql中获取数据

### 缓存穿透、缓存击穿、缓存雪崩

**缓存雪崩**：在同一时间内 大量key同时过期 导致大量请求绕过redis缓存 直接到达数据库 数据库压力激增 进而导致数据库崩溃
**解决办法**：

1. 过期时间设置随机值：如果业务中的确有数据同时失效 可以使用expire 给每一个数据设置过期时间时 增加一个很小的随机数 不同数据的过期时间有差别，但是差别又不大，避免大量数据同时过期。 同时保证数据基本在相近时间失效，仍能满足业务需求。
2. redis集群部署：集群部署的情况下，我们就无须担心某一台Redis宕机导致触发缓存雪崩，也可以将热点数据均匀分布在不同Redis库中，来避免全部失效的问题。
3. 服务熔断或降级：发生缓存雪崩，针对不同的数据采用不同的处理方式：当业务应用访问的是非核数据时候，暂时停止从缓存中查询这些数据，而是直接返回预定义信息或者空数据。当业务应用访问的是核心数据，仍然允许查询缓存，如果缓存缺失也可以继续通过数据库读取。
4. 热点数据永不过期：让热点数据永不过期，只进行更新的操作，这也可以避免缓存雪崩。但可能会带来数据不一致的问题。
5. 提前预热缓存数据：在系统启动之后，或者系统运行期间定期地将一些缓存数据直接加载到缓存系统，这样就可以避免等到用户请求的时候再去查询数据库，然后再将数据回写到缓存。

**缓存击穿**：针对某个访问非常频繁的热点数据请求 当缓存过期失效时 大量请求发送到数据库中 导致数据库压力激增 影响数据库处理其他请求

**解决办法**：

1. 对于访问特别频繁的热点数据，不再设置过期时间。
2. 对于热点数据的请求访问，都可以在缓存中进行处理。
3. 添加互斥锁

**缓存穿透**：

 持续有大量请求访问既不是Redis缓存中也不再数据库中的数据，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。同时给缓存和数据库带来巨大压力 

**原因**：

1. 业务层误操作：缓存中的数据和数据库中的数据都被误删除，所以缓存和数据库中都没有数据；    
2. 恶意攻击：专门访问数据库中没有的数据

**解决办法**：

1. 缓存空值或者缺省值
    一旦发生缓存穿透，针对查询数据在Redis缓存一个空值或者业务层协商确定的缺省值。应用发生后续请求在进行查询时，可以直接从Redis读取空值或者缺省值返回给业务应用，避免大量请求发送给数据库处理，保持数据库的正常运行。
2. 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。
3. 前端对非法请求校验，避免请求进入缓存或者数据库。

## 限流问题

本地限流和分布式redis限流相结合的限流架构，通过Nginx的漏桶限流算法， 对于⽤户维度进⾏1r/m的限流策略。通过实现Redis+Lua分布式令牌桶限流组件，对于商品维度进 ⾏限流，对于每个sku进⾏限流10000r/s。

### 流量预估

大体过程 通过⽤户量推算PV公式：

```
//估计⽇活⽤户是总⽤户的20%，淘宝双11⽇活⽤户⼤概50-60%
(总⽤户数 * 20%) * 每天⼤概点击次数(经验值30-50次)=PV
//千万⽤户PV计算如下
1000万*20%*30=6000万
```

通过PV推算QPS的公式：

```java
//根据80/20原则，80%点击量发⽣在20%的时间
(每天PV数 * 80%) / (每天秒数 * 20%) = 峰值时间的每秒请求数(QPS)
//千万⽤户QPS计算如下
(6000万 * 0.8) / (86400 * 0.2) = 2700
```

冗余系数 评估出来指标后，为了更加保险，需要乘以⼀个冗余系数，防⽌任务评估造成预期指标偏低的情况。 这个冗余系数⼀般定为2-5之间（⾏业经验）

```
//千万⽤户加⼊冗余系数的QPS
2700(QPS) * 4 = 10800(QPS)
```



## Docker



## 如何保证幂等性

​    全局唯一ID（根据业务的操作和内容生成一个全局的ID，在执行操作前，先根据全局唯一ID是否存在，来判断是否执行。如果不存在，则保存到全局ID，存储到数据库或者Redis）、去重表、插入或更新、多版本控制  

## 读写分离

  读写分离，就是根据二八原则嘛，百分之二十的操作是写操作，百分之八十的操作是读操作。那么从数据库这边可以配置读写分离，把读操作和写操作分离出来，最大程度的利用好数据库服务器。就是在执行SQL语句的时候，判断到底是读操作还是写操作，把读操作转向读操作服务器，写的操作转到写服务器上。 并且为了保证多台数据库的一致性，需要主从复制。 mysql有bin日志（二进制日志），会记录下所有修改过数据库的sql语句。主服务器读一遍，从服务器读一遍。关于如何判断是读还是写操作的话，我们因为分库分表，所以有读的数据库服务器、写的数据库服务器。最常用的SQL语句就是select去110服务器执行insert、update、delete去120服务器执行。剩下的就基础的数据同步交给mysql这种数据库软件自动处理了。

## Token Auth的优势

1.支持跨域访问: Cookie是不允许垮域访问的,这一点对 Token机制是不存在的,前提是传输的用户认证信息通过HTTP头传输.
2.无状态(也称:服务端可扩展行) :Token机制在服务端不需要存储 session信息,因为Token自身包含了所有登录用户的信息,只需要在客户端的 Cookie或本地介质存储状态信息
3.更适用CDN:可以通过内容分发网络请求你服务端的所有资料(如: Javascript,HTML,图片等),而你的服务端只要提供API即可
4.去耦:不需要绑定到一个特定的身份验证方案。 Token可以在任何地方生成,只要在你的API被调用的时候,你可以进行 Token生成调用即可
5.更适用于移动应用:当你的客户端是一个原生平台(iOS, Android, Windows8等)时, Cookie是不被支持的(你需要通过 Cookie容器进行处理),这时采用 Token认证机制就会简单得多。
6.CSRF:因为不再依赖于 Cookie,所以你就不需要考虑对CSRF(跨站请求伪造)的防范。
7.性能:一次网络往返时间(通过数据库查询 session信息.)总比做一次 HMACSHA256计算的 Token验证和解析要费时得多。
8.不需要为登录页面做特殊处理:如果你使用 Protractor做功能测试的时候,不再需要为登录页面做特殊处理
9.基于标准化:你的API可以采用标海化的 JSON Web Token(WT.这个标准已经存在多个后端库(NET, Ruby, Java. Python,PHP)和多家公司的支持(如Firebase. Google, Microsoft)

## JWT简介

JSON Web Token(JWT)是一个非常轻巧的规范。这个规范允许我们使用T在用户和服务器之间传递安全可靠的信息.。

JWT组成
一个JWT实际上就是一个字符串,它由三部分组成,头部、载荷与签名。
头部：存放声明信息，加密、编码方式等。可以被表示成一个JSON对象。

载荷：存放一些有效信息。
包含三部分：
（1）标准中注册的声名（建议但不强制使用）

   (2)公共的声明
公共的声明可以添加任何的信息,一般添加用户的相关信息或其他业务需要的必要信息但不建议添加敏感信息,因为该部分在客户端可解密。
   (3)私有的声明
私有声明是提供者和消费者所共同定义的声明,一般不建议存放敏感信息,因为base64是对称解密的,意味着该部分信息可以归类为明文信息。

这个指的就是自定义的claim。比如前面那个结构举例中的 admin和name都属于自定的Claim。这些claim跟JWT标准规定的 claim区别在于:JWMT规定的 claim,JWT的接收方在拿到WT之后,都知道怎么对这些标准的dam进行验证(还不知道是否能够验证:而private claims不会验证,除非明确告诉接收方要对这些aim进行验证以及规则才行。

jwt的第三部分是一个签证信息,这个签证信息由三部分组成:
header ( base64编码后的 )
payload ( base64 89编码后的 )
secret
这个部分需要base64加密后的 header和base64加密后的 payload使用连接组成的字符串,然后通过 header中声明的加密方式进行加盐 secret组合加密,然后就构成了JWT的第三部分。

这三部分base64编码后的字符串用”.“连接，最终构成一个完整的jwt。
示例：
注意: secret是保存在服务器端的,jwt的签发生成也是在服务器端的, secret就是用来进行jwt的签发和jwt的验证,所以,它就是你服务端的私钥,在任何场景都不应该流露出去。一旦客户端得知这个 secret,那就意味着客户端是可以自我签发jwt了。

## java的JJWT实现JWT

JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。

## 解决跨域



## 项目版本管理



## 数据库问题

### 索引失效的原因

## Nginx 

### 负载均衡的方式

## Git 

### 解决版本冲突问题

### 分支

一个主分支 然后在这个分支下进行



## 测试

与测试人员联调 各个接口联调 

跟其他接口、模块、系统 调试

使用专门的禅道来将问题进行传递 测试人员会把问题的描述等信息提供给我 我在根据提供的信息来进行解决



3/2时间是开发 3/1 
